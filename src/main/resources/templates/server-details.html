<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="de">
<head>
    <meta charset="UTF-8" />
    <title th:text="'Details für ' + ${server.name}">Serverdetails</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" th:href="@{'/css/' + ${theme}}">
	<link rel="icon" href="/img/logo.png" type="image/png">
	<link rel="stylesheet" href="/css/details.css">
	<link rel="stylesheet" th:href="@{'/css/' + ${theme} + '-sidebar.css'}">
</head>
<body>
	<header>
	    <h1 th:text="'Serverdetails für ' + ${server.name}">Details</h1>
	</header>

	<div th:replace="fragments/sidebar :: sidebar"></div>
	
<section>
    <div class="charts-container">
        <div class="charts-container">
        <p><img src="/img/cpu.png" alt="CPU Icon" style="height: 1em; margin-right: 0.5rem;"> <strong>CPU:</strong> <span id="cpuText">-</span> %</p>
        <p><img src="/img/ram.png" alt="RAM Icon" style="height: 1em; margin-right: 0.5rem;"> <strong>RAM:</strong> <span id="ramText">-</span> MB</p>
        <p><img src="/img/ssd.png" alt="SSD Icon" style="height: 1em; margin-right: 0.5rem;"> <strong>Storage:</strong> <span id="storageText">-</span> GB</p>
        </div>
        <div class="charts-container">
		<p><strong>Boot Zeit:</strong> <span th:text="${server.boottime}">-</span></p>
		<p><strong>Uptime:</strong> <span th:text="${server.uptime}">-</span></p>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-wrapper">
            <canvas id="cpuLineChart" aria-label="CPU Auslastung Diagramm" role="img"></canvas>
        </div>
        <div class="chart-wrapper">
            <canvas id="ramLineChart" aria-label="RAM Verwendung Diagramm" role="img"></canvas>
        </div>
		<div class="chart-wrapper">
		    <canvas id="swapChart" aria-label="Swap Speicher" role="img"></canvas>
		</div>
        <div class="chart-wrapper">
            <canvas id="storageDoughnutChart" aria-label="Storage Diagramm" role="img"></canvas>
        </div>
		<div class="chart-wrapper">
			<h2>Serverstandort</h2>

			<div th:if="${geoInfo != null}">
			    <p>
			        Stadt: <span th:text="${geoInfo.city}">unbekannt</span><br/>
			        Land: <span th:text="${geoInfo.country}">unbekannt</span><br/>
			        Koordinaten: 
			        <span th:text="${geoInfo.lat}">0.0</span>, 
			        <span th:text="${geoInfo.lon}">0.0</span>
			    </p>
			</div>
			<div th:if="${geoInfo == null}">
			    <p>Keine Geo-Informationen für diesen Server verfügbar.</p>
			</div>
	</div>
    </div>
	
	<div class="charts-container" style="flex-direction: column;">
	    <div class="chart-wrapper" style="max-width: none;">
	        <canvas id="combinedLineChart" aria-label="Verlauf CPU, RAM, Storage" role="img" style="height: 300px;"></canvas>
	    </div>
	</div>
	
	<h2>CPU Kernauslastung</h2>
	<table class="hardware-table">
	  <thead>
	    <tr>
	      <th>Kern</th>
	      <th>Last (%)</th>
	      <th>Frequenz (GHz)</th> <!-- Neue Spalte -->
	      <th>Auslastungsbalken</th>
	    </tr>
	  </thead>
	  <tbody id="cpuCoreTableBody"></tbody>
	</table>




	<h2>Hardwareinformationen</h2>
	<table class="hardware-table">
	    <thead>
	        <tr>
	            <th>Komponente</th>
	            <th>Wert</th>
	        </tr>
	    </thead>
	    <tbody>
	        <tr th:each="entry : ${hardwareInfo}">
	            <td th:text="${entry.key}">Key</td>
	            <td th:text="${entry.value}">Wert</td>
	        </tr>
	    </tbody>
	</table>

	
	<h2>Top Prozesse</h2>
	<table class="hardware-table">
	  <thead>
	    <tr>
	      <th>PID</th>
	      <th>Name</th>
	      <th>
	        <img src="/img/cpu.png" alt="CPU Icon" class="icon"> CPU (%)
	      </th>
	      <th>
	        <img src="/img/ram.png" alt="RAM Icon" class="icon"> RAM (MB)
	      </th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr th:each="proc : ${server.processes}">
	      <td th:text="${proc.pid}">PID</td>
	      <td th:text="${proc.name}">Name</td>
	      <td th:text="${#numbers.formatDecimal(proc.cpu, 1, 2)}">CPU</td>
	      <td th:text="${proc.ram}">RAM</td>
	    </tr>
	    <tr th:if="${#lists.isEmpty(server.processes)}">
	      <td colspan="4" class="no-data">Keine Prozessdaten verfügbar</td>
	    </tr>
	  </tbody>
	</table>

	<h2>Plugins</h2>
	<div id="pluginContainer">
	    <p>Lade Plugin-Daten...</p>
	</div>
		
		<div style="display: flex; flex-wrap: wrap; gap: 2rem; margin-top: 2rem;">
		
		<!-- Erweiterte Auswertung -->
		<div style="flex: 1; min-width: 300px; max-width: 600px;">
		<h2>Erweiterte Auswertung</h2>

		<form id="advancedQueryForm" style="max-width: 600px; margin-top: 1rem; display: flex; flex-direction: column; gap: 0.8rem;">
		  
		  <label for="filterType"><strong>Filter auswählen:</strong><br>
		    Wählen Sie eine Art der Auswertung, z.B. wie oft ein Wert einen Grenzwert überschreitet, oder den Durchschnitt.
		  </label>
		  <select id="filterType" name="filterType" required>
		    <option value="">-- Bitte wählen --</option>
		    <option value="countAbove">Anzahl der Werte über einem Schwellenwert</option>
		    <option value="average">Durchschnittswert über den Zeitraum</option>
		    <option value="maxValue">Höchster Wert</option>
		    <option value="minValue">Niedrigster Wert</option>
		  </select>

		  <label for="component"><strong>Komponente auswählen:</strong><br>
		    Wählen Sie die Komponente, deren Werte ausgewertet werden sollen.
		  </label>
		  <select id="component" name="component" required>
		    <option value="">-- Bitte wählen --</option>
		    <option value="cpuPercent">CPU-Auslastung (%)</option>
		    <option value="ramUsed">RAM-Verbrauch (GB)</option>
		    <option value="diskPercent">Festplatten-Auslastung (%)</option>
		  </select>

		  <label for="threshold" id="thresholdLabel" style="display:none;">
		    <strong>Schwellenwert eingeben:</strong><br>
		    Geben Sie hier den Grenzwert ein, z.B. 80 (wird nur bei "Anzahl Werte über Schwellenwert" benötigt).
		  </label>
		  <input type="number" id="threshold" name="threshold" min="0" step="any" style="display:none;" placeholder="z.B. 80">

		  <button type="submit" style="align-self: start; padding: 0.5rem 1rem;">Auswerten</button>
		</form>

		<div id="queryResult" style="margin-top: 1.5rem; font-size: 1.2rem; color: #4a90e2; min-height: 2rem;"></div>
		</div>
		

		<div style="flex: 1; min-width: 300px; max-width: 600px;">
		<h2>Warnschwellen festlegen</h2>
		<form id="thresholdForm">
		    <input type="number" name="cpu" placeholder="CPU max (%)" min="1" max="100" required>
		    <input type="number" name="ram" placeholder="RAM max (%)" min="1" max="100" required>
		    <input type="number" name="disk" placeholder="Disk max (%)" min="1" max="100" required>
		    <input type="email" name="email" placeholder="E-Mail für Alarm" required>
		    <button type="submit">Trigger speichern</button>
		</form>
		<p id="saveStatus" style="color: lightgreen;"></p>
		</div>
		
	</div>
</section>


<script th:inline="javascript">
    const serverName = /*[[${server.name}]]*/ "";

    const cpuData = [];
    const ramData = [];
    const labels = [];

    const maxPoints = 30;

    const cpuCtx = document.getElementById('cpuLineChart').getContext('2d');
    const ramCtx = document.getElementById('ramLineChart').getContext('2d');
    const storageCtx = document.getElementById('storageDoughnutChart').getContext('2d');

	const centerTextPlugin = {
	    id: 'centerText',
	    beforeDraw: function(chart) {
	        if (chart.config.options.plugins.centerText) {
	            const ctx = chart.ctx;
	            const text = chart.config.options.plugins.centerText.text;
	            const fontSize = chart.config.options.plugins.centerText.fontSize || '16';
	            const color = chart.config.options.plugins.centerText.color || '#fff';

	            const chartArea = chart.chartArea;
	            const centerX = (chartArea.left + chartArea.right) / 2;
	            const centerY = (chartArea.top + chartArea.bottom) / 2;

	            ctx.save();
	            ctx.font = `${fontSize}px sans-serif`;
	            ctx.fillStyle = color;
	            ctx.textAlign = 'center';
	            ctx.textBaseline = 'middle';
	            ctx.fillText(text, centerX, centerY);
	            ctx.restore();
	        }
	    }
	};
	Chart.register(centerTextPlugin);

	
    const cpuChart = new Chart(cpuCtx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'CPU-Auslastung (%)',
                data: cpuData,
                borderColor: 'rgba(255, 99, 132, 1)',
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                fill: true,
                tension: 0.3,
                pointRadius: 2,
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        stepSize: 20
                    }
                }
            },
            plugins: {
                legend: { labels: { font: { size: 14 } } }
            }
        }
    });

    const ramChart = new Chart(ramCtx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'RAM-Verwendung (GB)',
                data: ramData,
                borderColor: 'rgba(54, 162, 235, 1)',
                backgroundColor: 'rgba(54, 162, 235, 0.25)',
                fill: true,
                tension: 0.3,
                pointRadius: 2,
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true
                }
            },
            plugins: {
                legend: { labels: { font: { size: 14 } } }
            }
        }
    });
	
	
	const swapCtx = document.getElementById('swapChart').getContext('2d');
	let swapChart = new Chart(swapCtx, {
	    type: 'doughnut',
	    data: {
	        labels: ['Verwendet', 'Frei'],
	        datasets: [{
	            data: [0, 0],
	            backgroundColor: ['rgba(255, 159, 64, 0.8)', 'rgba(100, 100, 100, 0.3)'],
	            borderWidth: 0
	        }]
	    },
	    options: {
	        responsive: true,
	        maintainAspectRatio: false,
	        cutout: '70%',
	        plugins: {
	            legend: {
	                position: 'bottom',
	                labels: {
	                    color: '#ddd',
	                    font: { size: 14 }
	                }
	            },
				centerText: {
				  	text: 'Swap',
			     	fontSize: 18,
	           		color: '#fff'
			     }
	        }
	    }
	});

    let storageChart;
	let combinedChart;

    async function updateData() {
		let server;
        try {
            const res = await fetch(`/api/server/${encodeURIComponent(serverName)}`);
            if (!res.ok) throw new Error("Fehler beim Laden");
            server = await res.json();
			console.log(server);

            // Text aktualisieren
            document.getElementById("cpuText").textContent = server.cpuPercent.toFixed(1);
            document.getElementById("ramText").textContent = server.ramUsed.toFixed(2) + " / " + server.ramTotal.toFixed(2);
            document.getElementById("storageText").textContent = server.storageUsed.toFixed(2) + " / " + server.storageTotal.toFixed(2);



            const now = new Date().toLocaleTimeString();
            if (labels.length >= maxPoints) {
                labels.shift();
                cpuData.shift();
                ramData.shift();
            }
            labels.push(now);
            cpuData.push(server.cpuPercent);
            ramData.push(server.ramUsed);

            cpuChart.update();
            ramChart.update();

            if (!storageChart) {
                storageChart = new Chart(storageCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Verwendet', 'Frei'],
                        datasets: [{
                            data: [server.storageUsed, server.storageTotal - server.storageUsed],
                            backgroundColor: ['rgba(255, 206, 86, 0.8)', 'rgba(100, 100, 100, 0.3)'],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: '#ddd',
                                    font: { size: 14 }
                                }
                            },
							centerText: {
							    text: 'Speicher',
							    fontSize: 18,
							    color: '#fff'
							}
                        }
                    }
                });
            } else {
                storageChart.data.datasets[0].data = [server.storageUsed, server.storageTotal - server.storageUsed];
                storageChart.update();
            }

        } catch (e) {
            console.error("Fehler beim Laden der Serverdaten:", e);
        }
		
		// Verlauf laden
		try {
		    const historyRes = await fetch(`/api/server/${encodeURIComponent(serverName)}/history`);
		    if (!historyRes.ok) throw new Error("Fehler beim Laden der Verlaufsdaten");
		    const history = await historyRes.json();
			const maxCombinedPoints = 70; // Begrenzung für kombiniertes Diagramm
			const trimmedHistory = history.slice(-maxCombinedPoints);

			const timestamps = trimmedHistory.map(entry => new Date(entry.timestamp).toLocaleTimeString());
			const cpuHistory = trimmedHistory.map(entry => entry.cpuPercent);
			const ramHistory = trimmedHistory.map(entry => entry.ramUsed / 1024);
			const diskHistory = trimmedHistory.map(entry => entry.diskPercent);

		    if (!combinedChart) {
		        const ctx = document.getElementById("combinedLineChart").getContext("2d");
		        combinedChart = new Chart(ctx, {
		            type: 'line',
		            data: {
		                labels: timestamps,
		                datasets: [
		                    {
		                        label: "CPU (%)",
		                        data: cpuHistory,
								yAxisID: 'yCPU',
		                        borderColor: "rgba(255,99,132,1)",
		                        backgroundColor: "rgba(255,99,132,0.2)",
		                        fill: false,
		                        tension: 0.3
		                    },
		                    {
		                        label: "RAM (GB)",
		                        data: ramHistory,
								yAxisID: 'yRAM',
		                        borderColor: "rgba(54,162,235,1)",
		                        backgroundColor: "rgba(54,162,235,0.2)",
		                        fill: false,
		                        tension: 0.3
		                    },
		                    {
		                        label: "Speicher (%)",
		                        data: diskHistory,
								yAxisID: 'yDisk',
		                        borderColor: "rgba(255,206,86,1)",
		                        backgroundColor: "rgba(255,206,86,0.2)",
		                        fill: false,
		                        tension: 0.3
		                    }
		                ]
		            },
		            options: {
		                responsive: true,
		                maintainAspectRatio: false,
						scales: {
						        yCPU: {
						            type: 'linear',
						            position: 'left',
						            beginAtZero: true,
						            max: 100,
						            title: { display: true, text: 'CPU (%)' }
						        },
						        yRAM: {
						            type: 'linear',
						            position: 'right',
						            beginAtZero: true,
						            suggestedMax: 32, // oder dynamisch setzen je nach RAM
						            title: { display: true, text: 'RAM (GB)' }
						        },
						        yDisk: {
						            type: 'linear',
						            position: 'right',
						            display: false
						        }
						    },
		                plugins: {
		                    legend: { labels: { font: { size: 14 } } }
		                }
		            }
		        });
		    } else {
		        combinedChart.data.labels = timestamps;
		        combinedChart.data.datasets[0].data = cpuHistory;
		        combinedChart.data.datasets[1].data = ramHistory;
		        combinedChart.data.datasets[2].data = diskHistory;
		        combinedChart.update();
		    }

		} catch (e) {
		    console.error("Fehler beim Laden des Verlaufs:", e);
		}

		
		// Swap-Werte als Zahl interpretieren
		const swapUsed = parseFloat(server.swapUsed ?? 0);
		const swapTotal = parseFloat(server.swapTotal ?? 0);
		const swapFree = swapTotal - swapUsed;

		// Swap-Diagramm aktualisieren
		swapChart.data.datasets[0].data = [swapUsed, swapFree];
		swapChart.update();
    }
	
	document.getElementById("thresholdForm").addEventListener("submit", async function(event) {
	    event.preventDefault();

	    const form = event.target;
		const data = {
		    cpu: parseFloat(form.cpu.value),
		    ram: parseFloat(form.ram.value),
		    disk: parseFloat(form.disk.value),
		    email: form.email.value
		};

	    try {
			const res = await fetch(`/api/trigger/${encodeURIComponent(serverName)}`, {
	            method: "POST",
	            headers: { "Content-Type": "application/json" },
	            body: JSON.stringify(data)
	        });

	        if (res.ok) {
	            document.getElementById("saveStatus").textContent = "Trigger erfolgreich gespeichert.";
	        } else {
	            document.getElementById("saveStatus").textContent = "Fehler beim Speichern.";
	        }
	    } catch (err) {
	        console.error("Trigger speichern fehlgeschlagen:", err);
	        document.getElementById("saveStatus").textContent = "Netzwerkfehler.";
	    }
	});
	
	
	
	const advancedForm = document.getElementById("advancedQueryForm");
	const thresholdInput = document.getElementById("threshold");
	const thresholdLabel = document.getElementById("thresholdLabel");
	const queryResult = document.getElementById("queryResult");

	// Zeige nur für passenden Filter den Schwellenwert Input an
	document.getElementById("filterType").addEventListener("change", (e) => {
	  const val = e.target.value;
	  if(val === "countAbove") {
	    thresholdInput.style.display = "inline-block";
	    thresholdLabel.style.display = "inline-block";
	    thresholdInput.required = true;
	  } else {
	    thresholdInput.style.display = "none";
	    thresholdLabel.style.display = "none";
	    thresholdInput.required = false;
	  }
	});

	// Funktion: Lädt Verlaufsdaten und führt die Abfrage aus
	async function performQuery(filterType, component, threshold) {
	  try {
	    const historyRes = await fetch(`/api/server/${encodeURIComponent(serverName)}/history`);
	    if (!historyRes.ok) throw new Error("Fehler beim Laden der Verlaufsdaten");
	    const history = await historyRes.json();

	    // Werte aus Verlauf extrahieren
	    const values = history.map(entry => {
	      if(component === "ramUsed") return entry.ramUsed / 1024; // RAM in GB (oder MB falls gewünscht)
	      else return entry[component];
	    });

	    let resultText = "";

	    if(filterType === "countAbove") {
	      const count = values.filter(v => v > threshold).length;
	      resultText = `Anzahl der Werte von ${component} über ${threshold}: ${count}`;
	    } else if(filterType === "average") {
	      const avg = values.reduce((a,b) => a+b, 0) / values.length;
	      resultText = `Durchschnittlicher Wert von ${component}: ${avg.toFixed(2)}`;
	    } else if(filterType === "maxValue") {
	      const max = Math.max(...values);
	      resultText = `Maximalwert von ${component}: ${max.toFixed(2)}`;
	    } else if(filterType === "minValue") {
	      const min = Math.min(...values);
	      resultText = `Minimalwert von ${component}: ${min.toFixed(2)}`;
	    } else {
	      resultText = "Unbekannter Filtertyp.";
	    }

	    queryResult.textContent = resultText;
	  } catch(e) {
	    queryResult.textContent = "Fehler bei der Auswertung: " + e.message;
	  }
	}

	advancedForm.addEventListener("submit", (e) => {
	  e.preventDefault();
	  const formData = new FormData(advancedForm);
	  const filterType = formData.get("filterType");
	  const component = formData.get("component");
	  const threshold = parseFloat(formData.get("threshold"));

	  performQuery(filterType, component, threshold);
	});
	
	document.addEventListener("DOMContentLoaded", () => {
	    updateData();
		setInterval(updateData, 4000);
	});
	
	function updateCpuCores() {
	    fetch(`/api/server/${serverName}`)
	        .then(response => response.json())
	        .then(server => {
	            const cpuCoreTableBody = document.getElementById("cpuCoreTableBody");
	            const cores = server.cpuCore || {};
	            const freqs = server.cpuCoreFreqs || {}; // Frequenzen

	            const existingRows = {};
	            Array.from(cpuCoreTableBody.rows).forEach(row => {
	                const coreName = row.cells[0].textContent;
	                existingRows[coreName] = row;
	            });

	            Object.entries(cores).forEach(([core, load]) => {
	                const coreName = `Kern ${core}`;
	                const loadText = `${load.toFixed(2)} %`;
	                const freqText = (freqs[core] !== undefined) ? `${freqs[core].toFixed(2)} GHz` : "-";

	                if (existingRows[coreName]) {
	                    // Werte aktualisieren
	                    existingRows[coreName].cells[1].textContent = loadText;
	                    existingRows[coreName].cells[2].textContent = freqText;

	                    const bar = existingRows[coreName].cells[3].firstElementChild;
	                    bar.style.width = `${load}%`;
	                    delete existingRows[coreName];
	                } else {
	                    // Neue Zeile anlegen
	                    const row = document.createElement("tr");

	                    const coreCell = document.createElement("td");
	                    coreCell.textContent = coreName;
	                    row.appendChild(coreCell);

	                    const loadCell = document.createElement("td");
	                    loadCell.textContent = loadText;
	                    row.appendChild(loadCell);

	                    const freqCell = document.createElement("td");
	                    freqCell.textContent = freqText;
	                    row.appendChild(freqCell);

	                    const barCell = document.createElement("td");
	                    const bar = document.createElement("div");
	                    bar.style.width = `${load}%`;
	                    bar.style.height = "10px";
	                    bar.style.backgroundColor = "rgba(255, 99, 132, 0.8)";
	                    bar.style.borderRadius = "3px";
	                    bar.style.transition = "width 0.5s ease";
	                    barCell.appendChild(bar);
	                    row.appendChild(barCell);

	                    row.style.verticalAlign = "middle";

	                    cpuCoreTableBody.appendChild(row);
	                }
	            });

	            // Entferne nicht mehr vorhandene Zeilen
	            for (const remainingRow of Object.values(existingRows)) {
	                cpuCoreTableBody.removeChild(remainingRow);
	            }
	        })
	        .catch(error => {
	            console.error("Fehler beim Abrufen der CPU-Kerne:", error);
	        });
	}

	// alle 5 Sekunden aktualisieren
	setInterval(updateCpuCores, 5000);
	updateCpuCores(); // direkt einmal initial aufrufen
	
	async function fetchPluginData() {
	    try {
	        const response = await fetch(`/api/plugins/${serverName}`);
	        if (!response.ok) throw new Error('Netzwerkfehler');
	        const data = await response.json();

	        const container = document.getElementById('pluginContainer');
	        container.innerHTML = ''; // Alte Inhalte löschen

	        if (!data || Object.keys(data).length === 0) {
	            container.innerHTML = '<p>Keine Plugin-Informationen verfügbar.</p>';
	            return;
	        }

	        for (const [pluginName, values] of Object.entries(data)) {
	            const pluginHeader = document.createElement('h3');
	            pluginHeader.textContent = pluginName;
	            container.appendChild(pluginHeader);

	            const ul = document.createElement('ul');
	            for (const [key, value] of Object.entries(values)) {
	                const li = document.createElement('li');
	                li.textContent = `${key}: ${value}`;
	                ul.appendChild(li);
	            }
	            container.appendChild(ul);
	        }

	    } catch (err) {
	        console.error('Fehler beim Laden der Plugin-Daten:', err);
	    }
	}

	// Erstmalig laden
	fetchPluginData();

	// Alle 5 Sekunden automatisch aktualisieren
	setInterval(fetchPluginData, 5000);
</script>
<script src="/js/sidebar.js"></script>
</body>
</html>
