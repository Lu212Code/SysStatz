<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Langzeit-Analyse</title>
	<link rel="stylesheet" th:href="@{'/css/' + ${theme}}">
	<link rel="icon" href="/img/logo.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        select {
            padding: 8px;
            border-radius: 6px;
            border: none;
            background-color: #2c2f48;
            color: #ddd;
            font-size: 1rem;
            margin: 20px auto;
            display: block;
        }
        canvas {
            background: #2c2f48;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 30px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5);
        }
        .analysis-box {
            background-color: #2c2f48;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5);
            max-width: 800px;
            margin: auto;
        }
        .analysis-box h3 {
            margin-top: 0;
            color: #7fbfff;
            border-bottom: 1px solid #4a90e2;
            padding-bottom: 6px;
        }
        .analysis-item {
            margin: 6px 0;
            font-size: 1rem;
            color: #ccc;
        }
    </style>
	<link rel="stylesheet" th:href="@{'/css/' + ${theme} + '-sidebar.css'}">
</head>
<body>

<header>
    <h1>Langzeit-Analyse</h1>
</header>

<div th:replace="fragments/sidebar :: sidebar"></div>

<select id="serverSelect">
    <option value="">-- Server auswÃ¤hlen --</option>
</select>

<canvas id="cpuChart"></canvas>
<canvas id="ramChart"></canvas>
<canvas id="diskChart"></canvas>

<div class="analysis-box">
    <h3>Analyse</h3>
    <div id="analysisContent">Bitte einen Server auswÃ¤hlen.</div>
</div>

<script>
    const serverSelect = document.getElementById('serverSelect');
    const analysisContent = document.getElementById('analysisContent');

    const cpuChart = makeChart('cpuChart', 'CPU %', '#f39c12');
    const ramChart = makeChart('ramChart', 'RAM %', '#4a90e2');
    const diskChart = makeChart('diskChart', 'Disk %', '#27ae60');

    function makeChart(id, label, color) {
        return new Chart(document.getElementById(id), {
            type: 'line',
            data: { labels: [], datasets: [{ label, data: [], borderColor: color, fill: false, tension: 0.1 }] },
            options: {
                responsive: true,
                scales: {
                    x: { type: 'time', time: { unit: 'minute' }, ticks: { color: '#ccc' } },
                    y: { ticks: { color: '#ccc' } }
                },
                plugins: { legend: { labels: { color: '#ccc' } } }
            }
        });
    }

    // Serverliste vom Backend holen
	fetch('/api/servers-from-files')
	  .then(r => r.json())
	  .then(servers => {
	    servers.forEach(serverName => {
	      const opt = document.createElement('option');
	      opt.value = serverName;
	      opt.textContent = serverName;
	      serverSelect.appendChild(opt);
	    });
	  });

	  serverSelect.addEventListener('change', () => {
	    if (!serverSelect.value) return;
	    fetch(`/api/server/${encodeURIComponent(serverSelect.value)}/longterm`)
	      .then(r => r.json())
	      .then(data => {
	        const times = data.map(d => new Date(d.timestamp * 1000));  // timestamp nicht time
	        const cpuVals = data.map(d => d.cpu);
	        const ramVals = data.map(d => d.ram);
	        const diskVals = data.map(d => d.disk);

			const smoothedCpu = smooth(cpuVals, 2);
			const smoothedRam = smooth(ramVals, 2);
			const smoothedDisk = smooth(diskVals, 2);
			
			let [cpuTimes, cpuValsSampled] = downsample(times, smoothedCpu, 200);
			let [ramTimes, ramValsSampled] = downsample(times, smoothedRam, 200);
			let [diskTimes, diskValsSampled] = downsample(times, smoothedDisk, 200);

			updateChartWithAllSpikes(cpuChart, cpuTimes, cpuValsSampled, 80, 80);
			updateChartWithAllSpikes(ramChart, ramTimes, ramValsSampled, 80, 80);
			updateChartWithAllSpikes(diskChart, diskTimes, diskValsSampled, 80, 80);

	        analysisContent.innerHTML = generateAnalysis(cpuVals, ramVals, diskVals);
	      });
	  });

    function updateChart(chart, labels, data) {
        chart.data.labels = labels;
        chart.data.datasets[0].data = data;
        chart.update();
    }
	
	function updateChartWithSpikes(chart, labels, data, threshold=80) {
	    const spikeIndexes = detectSpikes(data, threshold);
	    const pointColors = data.map((val, i) => spikeIndexes.includes(i) ? 'red' : chart.data.datasets[0].borderColor);

	    chart.data.labels = labels;
	    chart.data.datasets[0].data = data;
	    chart.data.datasets[0].pointBackgroundColor = pointColors;
	    chart.update();

	    return spikeIndexes.length;
	}
	
	function updateChartWithWideSpikes(chart, labels, data, threshold=80) {
	    const spikeIndexes = detectWidePeaks(data, threshold);
	    const pointColors = data.map((val, i) => spikeIndexes.includes(i) ? 'red' : chart.data.datasets[0].borderColor);

	    chart.data.labels = labels;
	    chart.data.datasets[0].data = data;
	    chart.data.datasets[0].pointBackgroundColor = pointColors;
	    chart.update();

	    return spikeIndexes.length;
	}
	
	function updateChartWithAllSpikes(chart, labels, data, smallThreshold=80, wideThreshold=80) {
	    const smallSpikes = detectSpikes(data, 5, smallThreshold/10);
	    const wideSpikes  = detectWidePeaks(data, wideThreshold);

	    const pointColors = data.map((_, i) => {
	        if (wideSpikes.includes(i)) return 'red';
	        if (smallSpikes.includes(i)) return 'yellow';
	        return chart.data.datasets[0].borderColor;
	    });

	    const pointRadius = data.map((_, i) => {
	        if (wideSpikes.includes(i)) return 6;    // rote breite Peaks
	        if (smallSpikes.includes(i)) return 4;   // gelbe normale Peaks
	        return 2;                                // normale Punkte sichtbar
	    });

	    chart.data.labels = labels;
	    chart.data.datasets[0].data = data;
	    chart.data.datasets[0].pointBackgroundColor = pointColors;
	    chart.data.datasets[0].pointRadius = pointRadius; 
	    chart.update();
	}

	function generateAnalysis(cpu, ram, disk) {
	    function avg(arr) { return (arr.reduce((a,b) => a+b, 0) / arr.length).toFixed(1); }
	    function max(arr) { return Math.max(...arr).toFixed(1); }
	    function min(arr) { return Math.min(...arr).toFixed(1); }
	    function risingTrend(arr) { 
	        let streak = 0, maxStreak = 0;
	        for (let i = 1; i < arr.length; i++) { if (arr[i] > arr[i-1]) streak++; else streak=0; maxStreak = Math.max(maxStreak, streak);}
	        return maxStreak >= 5;
	    }
	    function volatility(arr) {
	        let diffs = []; for (let i=1;i<arr.length;i++) diffs.push(Math.abs(arr[i]-arr[i-1]));
	        return (diffs.reduce((a,b)=>a+b,0)/diffs.length).toFixed(2);
	    }
	    function spikeCount(arr, threshold=80) { return detectSpikes(arr, threshold).length; }

	    return `
	        <div class="analysis-item"><b>CPU:</b> âŒ€ ${avg(cpu)}%, Max ${max(cpu)}%, Min ${min(cpu)}%, 
	            ${risingTrend(cpu)?'ðŸ“ˆ LÃ¤ngerer Anstieg':'âž¡ keine AuffÃ¤lligkeit'}, 
	            VolatilitÃ¤t: ${volatility(cpu)}%, Spikes: ${spikeCount(cpu)}</div>
	        <div class="analysis-item"><b>RAM:</b> âŒ€ ${avg(ram)}%, Max ${max(ram)}%, Min ${min(ram)}%, 
	            ${risingTrend(ram)?'ðŸ“ˆ LÃ¤ngerer Anstieg':'âž¡ keine AuffÃ¤lligkeit'}, 
	            VolatilitÃ¤t: ${volatility(ram)}%, Spikes: ${spikeCount(ram)}</div>
	        <div class="analysis-item"><b>Disk:</b> âŒ€ ${avg(disk)}%, Max ${max(disk)}%, Min ${min(disk)}%, 
	            ${risingTrend(disk)?'ðŸ“ˆ LÃ¤ngerer Anstieg':'âž¡ keine AuffÃ¤lligkeit'}, 
	            VolatilitÃ¤t: ${volatility(disk)}%, Spikes: ${spikeCount(disk)}</div>
	    `;
	}
	
	function detectSpikes(data, window = 5, factor = 2) {
	    const spikes = [];
	    for (let i = 0; i < data.length; i++) {
	        const start = Math.max(0, i - window);
	        const end = Math.min(data.length - 1, i + window);
	        const local = data.slice(start, end + 1);
	        const avg = local.reduce((a,b) => a+b, 0) / local.length;
	        const std = Math.sqrt(local.reduce((a,b) => a + (b - avg)**2, 0) / local.length);
	        if (data[i] > avg + factor * std) spikes.push(i);
	    }
	    return spikes;
	}
	
	function smooth(data, factor = 3) {
	    const result = [];
	    for (let i = 0; i < data.length; i++) {
	        const start = Math.max(0, i - factor);
	        const end = Math.min(data.length - 1, i + factor);
	        const avg = data.slice(start, end + 1).reduce((a,b)=>a+b,0)/(end-start+1);
	        result.push(avg);
	    }
	    return result;
	}
	
	function detectWidePeaks(data, threshold = 80) {
	    const spikes = [];
	    for (let i = 1; i < data.length - 1; i++) {
	        if (data[i] > threshold && data[i] > data[i-1] && data[i] > data[i+1]) {
	            spikes.push(i);
	        }
	    }
	    return spikes;
	}
	
	function downsample(times, values, maxPoints = 300) {
	    const step = Math.ceil(values.length / maxPoints);
	    const sampledTimes = [];
	    const sampledValues = [];
	    for (let i = 0; i < values.length; i += step) {
	        sampledTimes.push(times[i]);
	        sampledValues.push(values[i]);
	    }
	    return [sampledTimes, sampledValues];
	}
</script>
<script src="/js/sidebar.js"></script>
</body>
</html>
